"""
Utility functions
"""

from __future__ import annotations

from typing import (
    Any,
    Protocol,
    Union,
)

import numpy as np
import numpy.typing as npt

from gradient_aware_harmonisation.exceptions import MissingOptionalDependencyError
from gradient_aware_harmonisation.spline import (
    Spline,
    SplineScipy,
    SumOfSplines,
)
from gradient_aware_harmonisation.timeseries import Timeseries


def timeseries_to_spline(timeseries: Timeseries) -> SplineScipy:
    """
    Estimates splines from timeseries arrays.

    Parameters
    ----------
    timeseries
        timeseries of format dict(time_axis = np.array, values = np.array)

    Returns
    -------
    spline :
        compute spline from timeseries data

    Raises
    ------
    ValueError
        Spline degree (`k`) is smaller or equal to length of time_axis
        in timeseries obj. Must be at least equal to spline degree.
        (Default spline degree is `k = 3`)
    """
    try:
        import scipy.interpolate
    except ImportError as exc:
        raise MissingOptionalDependencyError(
            "timeseries_to_spline", requirement="scipy"
        ) from exc

    spline = SplineScipy(
        scipy.interpolate.make_interp_spline(
            timeseries.time_axis, timeseries.values
        )
    )

    return spline


class GetHarmonisedSplineLike(Protocol):
    """
    A callable which can generate a final, harmonised spline

    The harmonised spline is generated based on a
    harmonised spline that doesn't consider convergence
    and a spline to which the final, harmonised spline should converge.
    """

    def __call__(
        self,
        harmonisation_time: Union[int, float],
        convergence_time: Union[int, float],
        harmonised_spline_no_convergence: Spline,
        convergence_spline: Spline,
    ) -> Spline:
        """
        Generate the harmonised spline

        Parameters
        ----------
        harmonisation_time
            Harmonisation time

            This is the time at and before which
            the solution should be equal to `harmonised_spline_no_convergence`.

        convergence_time
            Convergence time

            This is the time at and after which
            the solution should be equal to `convergence_spline`.

        harmonised_spline_no_convergence
            Harmonised spline that does not consider convergence

        convergence_spline
            The spline to which the result should converge

        Returns
        -------
        :
            Harmonised spline
        """

def interpolate_timeseries(
    harmonisee: Spline,
    harmonised: Spline,
    harmonisation_time: Union[int, float],
    timeseries_harmonisee: Timeseries,
    decay_weights: npt.NDArray[Any],
) -> Timeseries:
    """
    Compute interpolated timeseries

    The interpolated timeseries is generated by interpolating
    between the harmonised spline at harmonisation time
    and the target spline at either
    the last date of the harmonisee or the specified convergence time.

    Parameters
    ----------
    harmonisee
        harmonisee spline

    harmonised
        harmonised (adjusted) spline

    harmonisation_time
        time point at which harmonisee and target should match

    timeseries_harmonisee
        timeseries of the harmonisee

    decay_weights
        sequence of weights decaying from 1 to 0

    Returns
    -------
    timeseries_interpolated :
        timeseries that interpolate between harmonised spline and harmonisee
    """
    if not np.isin(
        np.float32(timeseries_harmonisee.time_axis), np.float32(harmonisation_time)
    ).any():
        msg = (
            f"{harmonisation_time=} is not a value in "
            f"{timeseries_harmonisee.time_axis=}"
        )
        raise NotImplementedError(msg)

    updated_time_axis = timeseries_harmonisee.time_axis[
        np.where(timeseries_harmonisee.time_axis >= harmonisation_time)
    ]
    harmonised_values = harmonised(updated_time_axis)
    harmonisee_values = harmonisee(updated_time_axis)
    values_interpolated = (
        decay_weights * harmonised_values + (1 - decay_weights) * harmonisee_values
    )

    timeseries_interpolated = Timeseries(
        time_axis=updated_time_axis,
        values=values_interpolated,
    )

    return timeseries_interpolated


def add_constant_to_spline(in_spline: Spline, constant: float | int) -> Spline:
    """
    Add a constant value to a spline

    Parameters
    ----------
    in_spline
        Input spline

    constant
        Constant to add

    Returns
    -------
    :
        Spline plus the given constant
    """
    try:
        import scipy.interpolate
    except ImportError as exc:
        raise MissingOptionalDependencyError(
            "add_constant_to_spline", requirement="scipy"
        ) from exc

    return SumOfSplines(
        spline_one=in_spline,
        spline_two=SplineScipy(
            scipy.interpolate.PPoly(
                c=[[constant]],
                # # TODO: Problem: Currently domain is defined for SumOfSplines
                # #  and SplineScipy should be specified only once
                # #  preferably in SplineScipy
                # x=in_spline.domain,
                # TODO: better solution for domain handling
                x=[-1e8, 1e8],
            )
        ),
    )
